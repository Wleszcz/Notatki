# 1\. **OpenGL – koncepcje ogólne**

## 1.1. Czym jest OpenGL?

- API do grafiki **2D i 3D w czasie rzeczywistym**, z akceleracją sprzętową.
    
- Obecny na:
    
    - Windows, Linux, macOS, Nintendo Switch.
- Standard NIE opisuje:
    
    - tworzenia okien,
        
    - komunikacji z użytkownikiem,
        
    - pętli głównej aplikacji.
        

## 1.2. Warianty OpenGL

- **OpenGL ES** – mobilny wariant dla Android/iOS.
    
- **WebGL** – wariant działający w przeglądarce (na bazie OpenGL ES 2.0).
    

* * *

# 2\. **Alternatywne API graficzne**

(slajd 3)

OpenGL ma wady:

- wiele wersji (OpenGL, ES, WebGL),
    
- przestarzały na nowych systemach Apple (iOS 12+, macOS 10.14+),
    
- niższa wydajność vs. niskopoziomowe API.
    

→ Alternatywy:

- **Vulkan** (następca OpenGL),
    
- **Metal** (Apple),
    
- **Direct3D** (Microsoft, Windows/Xbox).
    

* * *

# 3\. **OpenGL ES w Androidzie**

## 3.1. Manifest aplikacji (slajd 4)

Kluczowe wpisy:

`<uses-feature android:glEsVersion="0x00020000" android:required="true" />`

Tworzenie aplikacji w pełnym ekranie, orientacja horyzontalna itp.

## 3.2. Główne klasy aplikacji (slajd 5–8)

1.  **GLSurfaceView** – widok renderujący GL.
    
2.  **Renderer** – posiada metody:
    
    - `onSurfaceCreated(...)` – inicjalizacja,
        
    - `onSurfaceChanged(...)` – ustalenie viewportu i projekcji,
        
    - `onDrawFrame(...)` – rysowanie każdej klatki.
        

Kod ilustruje:

- tworzenie macierzy widoku (`Matrix.setLookAtM`),
    
- ustawianie projekcji (`Matrix.frustumM`),
    
- transformacje modelu (skalowanie, rotacja, przesunięcie).
    

* * *

# 4\. **Projektowanie sceny 3D**

## 4.1. Podstawowe elementy modelu (slajd 10)

- pozycje wierzchołków,
    
- wektory normalne,
    
- kolory,
    
- współrzędne UV,
    
- sposób renderowania (punkty/linie/trójkąty).
    

## 4.2. Rysowanie prymitywów – sposób klasyczny (OpenGL 1.x)

Pokazano:

- punkty,
    
- linie i line strip,
    
- trójkąty,
    
- quady,
    
- interpolację kolorów.
    

Grafiki na slajdach 11–15 jasno pokazują efekt wyświetlania.

* * *

# 5\. **Wektory normalne i cieniowanie**

(slajdy 16–18)

- Normalne mogą być:
    
    - liczone **per-face** (ostrzejsze krawędzie),
        
    - liczone **per-vertex** (płynne cieniowanie, smooth shading).
        
- Wektor normalny określa jak fragment reaguje na światło.
    
- Slajd 17 zawiera porównanie dwóch torusów – wyraźna różnica.
    

* * *

# 6\. **Mapowanie tekstur**

(slajd 19)

- Każdy wierzchołek otrzymuje współrzędne `glTexCoord2f(u, v)`.
    
- Tekstura odwzorowywana jest na trójkąty.
    
- Kod przykładowy pokazuje dwie ściany sześcianu.
    

* * *

# 7\. **Transformacje 3D – macierze**

(slajdy 20–27)

OpenGL ES używa macierzy:

- **modelu** (`modelMatrix`),
    
- **widoku** (`viewMatrix`),
    
- **projekcji** (`projectionMatrix`).
    

### 7.1. Przesunięcie

`Matrix.translateM(...)`

### 7.2. Skalowanie

`Matrix.scaleM(...)`

### 7.3. Obrót

`Matrix.rotateM(...)`

Slajdy 22–27 zawierają **pełne matematyczne wyprowadzenia** macierzy.

⚠️ Uwaga (slajd 27):  
**OpenGL stosuje odwrotną kolejność definicji transformacji**  
→ najpierw translation, potem rotation, na końcu scale.

* * *

# 8\. **Różnice: OpenGL vs OpenGL ES**

(slajd 28)

- brak `glBegin()` i `glEnd()`,
    
- brak quadów – trzeba używać trójkątów,
    
- konieczne bufory danych i VBO.
    

* * *

# 9\. **OpenGL ES 2.0 – podejście współczesne**

## 9.1. Atrybuty i bufory danych (slajdy 29–31)

Dane muszą być przygotowane w tablicach:

- positions,
    
- colors,
    
- normals.
    

Następnie umieszczone w `FloatBuffer` i przekazane do shaderów via:

`glVertexAttribPointer(...)glEnableVertexAttribArray(...)`

* * *

# 10\. **Vertex Buffer Objects – VBO**

(slajdy 32–38)

## 10.1. Co to jest?

- Bufory na GPU, a nie w RAM.
    
- Dużo szybszy rendering.
    

## 10.2. Dane indeksowane (slajdy 33–34)

- Vertices przechowujesz w jednym buforze.
    
- Osobny bufor indeksów określa kolejność rysowania.
    

## 10.3. Proces użycia VBO

1.  `glGenBuffers`
    
2.  `glBindBuffer`
    
3.  `glBufferData`
    
4.  Ustawienie wskaźników atrybutów
    
5.  `glDrawElements`
    

## 10.4. Modyfikacja istniejących danych

Używamy:

`glBufferSubData(...)`

* * *

# ⭐ Podsumowanie OpenGL ES cz.1

Masz kompletny przegląd pipeline'u OpenGL ES 2.0:

- GLESView + Renderer,
    
- macierze M/V/P,
    
- podstawy modelowania (prymitywy, normalne, tekstury),
    
- transformacje,
    
- bufory danych,
    
- VBO i IBO.