# 1\. **API i standardy grafiki 3D**

Nowoczesne urządzenia mobilne wspierają kilka głównych bibliotek służących do renderowania grafiki 3D.

## 1.1. OpenGL ES

- Okrojona wersja OpenGL, dostosowana do urządzeń mobilnych.
    
- Rozwijany od 2003 r.
    
- Dostępny na: **Android, iOS (do iOS 12 – później przestarzały), Tizen, Nintendo Switch**.
    
- Tradycyjnie najpopularniejszy standard 3D w mobilnych grach i aplikacjach.
    

## 1.2. Vulkan

- Oficjalny następca OpenGL / OpenGL ES.
    
- Szybszy, ale też **dużo trudniejszy** w użyciu.
    
- Rozwijany od 2016 r.
    
- Dostępny na: **Android, Tizen, Nintendo Switch**.
    
- Pozwala na znacznie większą kontrolę nad GPU i minimalizuje narzut sterownika.
    

## 1.3. Metal

- Technologia Apple od 2014 r.
    
- Przeznaczona wyłącznie dla systemów Apple:
    
    - **iOS, iPadOS, macOS, tvOS**.
- Bardzo wydajna, zastąpiła OpenGL w ekosystemie Apple.
    

* * *

# 2\. **Silniki 3D i silniki gier**

Silnik 3D zapewnia **warstwę pośrednią** pomiędzy aplikacją a API graficznymi.  
Silniki gier to silniki 3D rozszerzone o:  
dźwięk, fizykę, sterowanie, networking itd.

## 2.1. Zalety użycia silnika 3D

- Ułatwia **tworzenie scen 3D**, materiałów, animacji, shaderów.
    
- Zapewnia **przenośność** — aplikacja działa podobnie na wielu platformach.
    
- Ułatwia zarządzanie assetami, animacjami i oświetleniem.
    

* * *

# 3\. **Najpopularniejsze silniki 3D**

## 3.1. Unreal Engine

- Rozwijany od 1998 r.
    
- Preferowany przez duże studia filmowe i growe.
    
- Ogromny zestaw narzędzi i gotowych efektów.
    
- Programowanie w **C++** lub **Blueprints (node-based)**.
    
- Darmowy do określonego poziomu przychodów, potem procent z zysków + licencje per stanowisko.
    

Ilustracja na str. 4 pokazuje przykład wysokiej jakości grafiki z gry *Jedi Fallen Order*.

## 3.2. Unity

- Pierwsza wersja: 2005 r.
    
- Najpopularniejszy na urządzeniach mobilnych.
    
- Prostszy w użyciu niż Unreal, ale oferuje mniej zaawansowane narzędzia.
    
- Programowanie w **C#**.
    
- Model opłat: % od przychodów + liczba instalacji aplikacji.
    

## 3.3. Godot (open-source)

- Platformy: **Android, iOS, HTML5, PC**.
    
- Języki: **C++, C#, GDScript, Visual Scripting**.
    
- Lekki, w pełni darmowy, bez opłat licencyjnych.
    

## 3.4. libGDX

- Platformy: **Android, iOS, HTML5, PC**.
    
- Język: **Java**.
    
- Popularny w mniejszych grach i projektach edukacyjnych.
    

## 3.5. jMonkeyEngine

- Platformy: **Android, Raspberry Pi, Desktop**.
    
- Języki: **Java, Kotlin, Groovy**.
    
- Jest to silnik 3D bardziej niż "game engine".
    

* * *

# 4\. **Na co zwracać uwagę przy wyborze silnika?**

## 4.1. Kryteria techniczne

- Czy silnik jest aktywnie rozwijany?
    
- Jakie formaty multimediów obsługuje?
    
- Czy obsługiwane są formaty eksportowane przez Twoje narzędzia (Blender, Maya, 3ds Max)?
    
- Jak dużo funkcjonalności działa na docelowej platformie mobilnej?
    
- Jakie komponenty zewnętrzne (np. ARCore, fizyka, sieć) są kompatybilne?
    

* * *

# 5\. **Podstawy grafiki 3D**

## 5.1. Rasteryzacja

(Zdjęcie z suzą – strona 10)

Proces przekształcenia sceny 3D w obraz 2D:

- każdy punkt 3D zostaje przeliczony macierzą projekcji;
    
- GPU wykonuje to w czasie rzeczywistym.
    

## 5.2. Field of View (FOV)

- Kąt widzenia kamery, zwykle określany w stopniach horyzontalnie.
    
- Krótsza ogniskowa → większy FOV → bardziej „szeroki” obraz.
    
- Jak wymiana obiektywu w aparacie:  
    krótkie 12 mm = szeroki kąt,  
    długie 200 mm = zoom.
    

Grafiki na str. 11 pokazują różnice FOV: 60°, 120°, 175°.

## 5.3. Ogniskowa (focal length)

- Odległość między środkiem optycznym a sensorem (w mm).
    
- Krótka ogniskowa = szeroki kąt, słabszy zoom.
    
- Rozmiar sensora wpływa na efektywne powiększenie (str. 12).
    

## 5.4. Projekcje

- **Perspektywiczna** – realistyczna (rzeczy w oddali wydają się mniejsze).
    
- **Ortograficzna** – brak perspektywy, często do map, RTS, CAD.
    

Str. 13 pokazuje porównanie obu.

* * *

# 6\. **Przycinanie i redukcja obliczeń (Clipping & Culling)**

Techniki poprawiające wydajność:

## 6.1. Clipping

- Wycinanie elementów poza polem widzenia kamery.

## 6.2. Culling – trzy główne techniki

### Occlusion culling

- Ukrywanie obiektów zasłoniętych przez inne obiekty.

### Backface culling

- Ukrywanie powierzchni „odwróconych” od kamery (tył modeli).

### Z-culling

- Wykorzystuje **z-buffer** (bufor głębi) do ustalania, który piksel jest bliżej.

Obraz na str. 14 pokazuje schemat działania.

* * *

# 7\. **Materiały i oświetlenie**

## 7.1. Materiał określa:

- teksturę,
    
- kolor,
    
- odbicia,
    
- oświetlenie,
    
- przezroczystość.
    

## 7.2. PBR — Physically Based Rendering

- Trend ostatnich lat.
    
- Materiały opisane parametrami bliskimi fizycznym cechom.
    
- Realistyczne zachowanie światła.
    

Zdjęcia PBR na str. 15 pokazują różne typy powierzchni.

* * *

# 8\. **Ray tracing i Path tracing**

## 8.1. Ray tracing

- Symulacja drogi światła **od źródła do kamery**.
    
- Bardzo realistyczne efekty odbić, refrakcji, cieni.
    
- Wymaga dużej mocy obliczeniowej.
    

## 8.2. Path tracing

- Uproszczona wersja ray tracingu.
    
- Promienie wysyłane od kamery w losowych kierunkach.
    
- Wartości są uśredniane – realistyczne, ale „ziarniste”.
    

Str. 16 pokazuje grafiki z przykładem path tracingu.

* * *

# 9\. **Post-processing (obróbka końcowa)**

Efekty nakładane na wyrenderowany obraz:

- korekcja kolorów,
    
- **Bloom** (jasna poświata),
    
- **Ambient Occlusion** (cienie szczelin),
    
- redukcja szumów,
    
- wiele innych filtrów.
    

Zdjęcia T-800 BEFORE/AFTER na str. 17.

* * *

# 10\. **Anti-aliasing**

## 10.1. Aliasing

- Powstaje, gdy próbki (piksele) są za rzadkie.
    
- Ząbkowane krawędzie.
    

## 10.2. Anti-aliasing

- Techniki wygładzania krawędzi:
    
    - FXAA (szybki),
        
    - MSAA,
        
    - SSAA (najlepszy, najbardziej kosztowny).
        

Ilustracje porównawcze na str. 18 pokazują wpływ metody.

* * *

# 11\. **Level of Detail (LOD)**

Technika optymalizacji:

- Obiekty dalej od kamery mają mniej szczegółów.
    
- Pozwala oszczędzać moc GPU.
    
- Na str. 19 widzimy model wieży w wielu wersjach:
    
    - od ~17k trójkątów do ~95 trójkątów.

* * *

# 12\. **Mipmapping**

- MipMapy = zmniejszone wersje tej samej tekstury.
    
- Zalety:
    
    - mniejszy aliasing przy małych obiektach,
        
    - oszczędność pamięci i mocy.
        

Str. 20 pokazuje piramidę MipMap (512×512 → 256×256 → …).

* * *

# 13\. **Techniki mapowania powierzchni**

## 13.1. Displacement Mapping

- Przesuwa **wierzchołki** modelu na podstawie heightmapy.
    
- Bardzo dokładne, ale wymaga wielu trójkątów.
    
- Porównanie na str. 21:
    
    - model z 1 986 → 48 841 wierzchołków.

## 13.2. Bump Mapping

- Symulacja wysokości **na etapie oświetlenia**, bez zmiany geometrii.
    
- Dopisuje „guzki” i detale w shaderze.
    
- Str. 22: 482 vs 4 wierzchołki → niemal identyczny efekt.
    

## 13.3. Normal Mapping

- Rozwinięcie bump mappingu.
    
- Każdy piksel ma wektor normalny (RGB → XYZ).
    
- Odchylenia normalnych symulują mikrostrukturę.
    
- Str. 23: realistyczny efekt przy minimalnej geometrii.
    

## 13.4. Parallax Occlusion Mapping (POM)

- Zaawansowane przesuwanie współrzędnych UV na podstawie depthmapy.
    
- Kilka próbek głębokości → interpolacja najbardziej prawdopodobnego kształtu.
    
- Str. 24 – wykres i demonstracja działania.
    

## 13.5. Porównanie metod

Na str. 25:

- Displacement Mapping (prawdziwa geometria) vs
    
- Parallax Occlusion Mapping (symulacja)  
    → bardzo zbliżony efekt przy minimalnej liczbie polygonów.
    

* * *

# 14\. **Normal mapping i POM w praktyce**

## 14.1. Normal mapping w grach

- Generowany często z modeli high-poly.
    
- Pozwala na:
    
    - świetne detale,
        
    - przy minimalnej liczbie wierzchołków.
        
- Str. 26: porównanie high poly → low poly → low poly z normal mapą.
    

## 14.2. Parallax Occlusion Mapping

- Stosowany w:
    
    - dachach,
        
    - chodnikach,
        
    - ścianach,
        
    - cegłach,
        
    - powierzchniach kamiennych.
        

Str. 27 pokazuje przykład z gry *Genshin Impact*.