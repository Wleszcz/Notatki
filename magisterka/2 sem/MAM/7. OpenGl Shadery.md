# 1\. **GLSL – wprowadzenie**

(GLSL = OpenGL Shading Language)

- Język wysokopoziomowy używany do programowania etapów pipeline’u GPU.
    
- Pozwala zmienić sposób:
    
    - cieniowania,
        
    - przetwarzania wierzchołków,
        
    - obliczania oświetlenia,
        
    - generowania kolorów.
        

Wprowadzenie shaderów → **pełna kontrola nad grafiką**.

* * *

# 2\. **Rodzaje shaderów**

(slajd 4)

1.  **Vertex Shader**
    
    - działa raz na każdy wierzchołek,
        
    - odpowiada za:
        
        - transformacje,
            
        - pozycję w przestrzeni clip-space,
            
        - pre-processing danych.
            
2.  **Fragment Shader (Pixel Shader)**
    
    - działa raz na każdy fragment (piksel po rasteryzacji),
        
    - odpowiada za kolorowanie.
        

* * *

# 3\. **Typy danych w GLSL**

(slajd 5)

- Skalary: `bool`, `int`, `uint`, `float`, `double`
    
- Wektory: `vec2`, `vec3`, `vec4`, `ivec4` itd.
    
- Dostęp do składowych:
    
    - `.xyzw`
        
    - `.rgba`
        
    - `.stpq`
        

Slajd 7 pokazuje przykład łączenia maskowań i swizzli.

* * *

# 4\. **Najprostsza para shaderów**

(slajd 8)

### Vertex shader:

`void main() { gl_Position = ftransform();}`

### Fragment shader:

`void main() { gl_FragColor = vec4(1.0,0.0,0.0,1.0); // czerwony}`

* * *

# 5\. **Komunikacja CPU ↔ Shader**

(slajd 9)

### `uniform`

- globalna stała (np. macierze, światło, czas).

### `attribute`

- dane per-vertex (pozycja, kolor).

### `varying`

- wartości interpolowane z VS do FS.

(Nowsze GLSL: `in` i `out`)

* * *

# 6\. **Shader z kolorem interpolowanym**

(slajd 10)

### Vertex shader:

`varying vec4 vColor;void main() { gl_Position = ftransform(); vColor = gl_Color;}`

### Fragment shader:

`uniform float alpha;varying vec4 vColor;void main() { gl_FragColor = vec4(vColor.rgb, alpha);}`

* * *

# 7\. **Macierze transformacji w GLSL**

(slajdy 11–12)

Predefiniowane zmienne:

- `gl_ModelViewMatrix`
    
- `gl_ProjectionMatrix`
    
- `gl_ModelViewProjectionMatrix`
    
- `gl_Vertex`
    

Trzy równoważne podejścia transformacji pozycji:

`gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;gl_Position = ftransform();`

* * *

# 8\. **Różnice OpenGL ES vs ES 1.1**

(slajd 13)

OpenGL ES 2.0:

- wymaga shaderów,
    
- brak gotowego pipeline'u,
    
- brak funkcji typu `glPushMatrix`, `glPopMatrix`,
    
- wszystkie macierze trzeba obliczyć samodzielnie.
    

* * *

# 9\. **Przekazywanie zmiennych do shaderów**

(slajd 15)

### W shaderze:

`uniform mat4 uMVPMatrix;attribute vec4 aPosition;`

### W kodzie Java:

`int pos = glGetAttribLocation(program, "aPosition");glEnableVertexAttribArray(pos);glVertexAttribPointer(...);int mvp = glGetUniformLocation(program, "uMVPMatrix");glUniformMatrix4fv(mvp, 1, false, mvpMatrix, 0);`

* * *

# 10\. **WebGL – grafika 3D w przeglądarce**

(slajdy 16–20)

- działa w `<canvas>`,
    
- API zgodne z OpenGL ES 2.0,
    
- wymaga shaderów,
    
- korzysta z bibliotek:
    
    - **glMatrix** (obliczenia macierzowe),
        
    - silniki WebGL: **Three.js**, **Babylon.js**, **J3D**, **SpiderGL**.
        

Slajdy 17–19 pokazują:

- inicjalizację kontekstu WebGL,
    
- tworzenie VBO,
    
- renderowanie sceny 3D.